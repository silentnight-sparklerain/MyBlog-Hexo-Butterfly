---
title: 计算机组成原理（4）：控制单元
categories:
  - Programming
  - Theory
comments: true
description: 计算机组成原理第四部分：控制单元
series: 计算机组成原理笔记
hide: true
mathjax: false
katex: true
highlight_shrink: true
cover: /img/posts/计算机组成原理.png
abbrlink: edc0bf5c
date: 2025-12-22 00:00:00
updated: 2025-12-22 00:00:00
keywords:
top_img:
aside:
aplayer:
---

## 第9章 控制单元的功能

本章重点分析控制单元（CU）如何发出微操作命令（控制信号），以实现指令周期中各个阶段（取指、间址、执行、中断）的操作。

### 9.1 微操作命令的分析

控制单元的核心功能是发出各种**微操作命令**（控制信号），指挥各部件协调工作。

**前提假设（硬件配置）**：
为了方便讨论，假设CPU内有以下寄存器：
*   **MAR**：存储器地址寄存器，连接地址总线。
*   **MDR**：存储器数据寄存器，连接数据总线。
*   **PC**：程序计数器，存放现行指令地址，有计数功能。
*   **IR**：指令寄存器，存放现行指令。

#### 9.1.1 取指周期 (Fetch Cycle)

所有指令的取指过程基本相同。
**目标**：从内存取指令 -> 送入IR -> PC+1。

**微操作序列**：
1.  **PC $\to$ MAR**：将指令地址送往MAR。
2.  **1 $\to$ R**：向主存发读命令。
3.  **M(MAR) $\to$ MDR**：主存将指令读入MDR。
4.  **MDR $\to$ IR**：将指令送入IR。
5.  **OP(IR) $\to$ CU**：将操作码送给CU译码。
6.  **(PC) + 1 $\to$ PC**：形成下条指令地址。

#### 9.1.2 间址周期 (Indirect Cycle)

**目标**：取操作数的有效地址（EA）。（针对间接寻址指令）

**微操作序列**：
1.  **Ad(IR) $\to$ MAR**：将指令中的形式地址送MAR。
2.  **1 $\to$ R**：向主存发读命令。
3.  **M(MAR) $\to$ MDR**：主存将有效地址读入MDR。
4.  **MDR $\to$ Ad(IR)**：将有效地址送回IR（有些机器可省略此步，直接用MDR作为地址）。

#### 9.1.3 执行周期 (Execute Cycle)

不同指令的执行操作各不相同。以下是典型指令的微操作序列（假设采用直接寻址）。

**1. 非访存指令**
*   **CLA (Clear ACC)**：`0 -> ACC`。
*   **COM (Complement ACC)**：`ACC -> ACC`（取反）。
*   **SHR (Arithmetic Shift Right)**：`L(ACC) -> R(ACC), ACC_0 -> ACC_0`（算术右移）。
*   **CSL (Cyclic Shift Left)**：`R(ACC) -> L(ACC), ACC_0 -> ACC_n`（循环左移）。
*   **STP (Stop)**：`0 -> G`（G为运行标志触发器，置0停机）。

**2. 访存指令**
*   **ADD X** (加法)：
    1.  `Ad(IR) -> MAR`
    2.  `1 -> R`
    3.  `M(MAR) -> MDR`
    4.  `(ACC) + (MDR) -> ACC`
*   **STA X** (存数)：
    1.  `Ad(IR) -> MAR`
    2.  `1 -> W` (写命令)
    3.  `ACC -> MDR`
    4.  `MDR -> M(MAR)`
*   **LDA X** (取数)：
    1.  `Ad(IR) -> MAR`
    2.  `1 -> R`
    3.  `M(MAR) -> MDR`
    4.  `MDR -> ACC`

**3. 转移类指令**
*   **JMP X** (无条件转移)：
    1.  `Ad(IR) -> PC`
*   **BAN X** (负则转)：
    1.  若 `A_0 = 1` (负)，则 `Ad(IR) -> PC`；否则 `(PC) + 1 -> PC` (取指阶段已完成+1，故无需操作)。

#### 9.1.4 中断周期 (Interrupt Cycle)

**目标**：保存断点，转中断服务程序入口。
**假设**：断点存入主存0号单元，入口地址由硬件向量法产生。

**微操作序列**：
1.  **0 $\to$ MAR**：将特定地址（如0）送MAR。
2.  **1 $\to$ W**：发写命令。
3.  **PC $\to$ MDR**：将断点（PC内容）送MDR。
4.  **MDR $\to$ M(MAR)**：将断点写入主存。
5.  **向量地址 $\to$ PC**：将中断服务程序入口地址送PC（为下个取指周期做准备）。
6.  **0 $\to$ EINT**：关中断。

### 9.2 控制单元的功能

#### 9.2.1 控制单元的外特性

![图 9.2 控制单元外特性](/img/post_article/计算机组成原理/9-2.png)

> *   **输入信号**：
>     1.  **时钟**：控制操作的节奏和先后顺序。
>     2.  **指令寄存器 (IR)**：提供操作码 (OP)，决定做什么操作。
>     3.  **标志**：来自ALU或PSW（如零标志、负标志），决定分支转移。
>     4.  **系统总线控制信号**：如中断请求、DMA请求等。
> *   **输出信号**：
>     1.  **CPU内控制信号**：控制寄存器传输、ALU运算等。
>     2.  **送至系统总线信号**：控制主存读写、I/O操作等。

#### 9.2.2 控制信号举例

**案例指令**：`ADD @X` (间接寻址加法指令)
*   **含义**：指令中给出的地址 $X$ 不是操作数的地址，而是操作数地址的地址。
*   **执行步骤**：取指令 $\to$ 取有效地址（间址） $\to$ 取操作数并运算（执行）。

**1. 不采用 CPU 内部总线的方式**

这种结构中，寄存器之间有**专用数据通路**（硬连线），不共用一条总线。

![图 9.3 未采用CPU内部总线方式的数据通路和控制信号**](/img/post_article/计算机组成原理/9-3.png)

> *   **结构特点**：
>     *   数据流动由各个**控制门**（图中的小圆圈）控制。
>     *   $C_0 \sim C_{12}$ 是控制信号，当信号有效时，对应的通路打通。
>     *   **ALU**可以直接连接AC和MDR，不需要额外的暂存器。

**详细操作流程：**

**(1) 取指周期 (Fetch Cycle)**
目标：把指令从内存取到IR，PC+1。
1.  **$C_0$ 有效**：打开 PC $\to$ MAR 的门。地址送入MAR。
2.  **$C_1$ 有效**：打开 MAR $\to$ 地址总线。
3.  **1 $\to$ R**：向主存发读命令。
4.  **$C_2$ 有效**：打开 数据总线 $\to$ MDR。指令进入MDR。
5.  **$C_3$ 有效**：打开 MDR $\to$ IR。指令进入IR，开始译码。
6.  **$C_4$ 有效**：操作码送CU。
7.  **(PC)+1 $\to$ PC**。

**(2) 间址周期 (Indirect Cycle)**
目标：根据指令中的形式地址，去内存找有效地址。
1.  **$C_5$ 有效**：打开 Ad(IR) $\to$ MAR。（将指令中的形式地址送MAR）。*(注：书中图9.3简化了，实际常由MDR送MAR)*
2.  **1 $\to$ R**：向主存发读命令。
3.  **$C_2$ 有效**：数据总线 $\to$ MDR。此时MDR里装的是**有效地址**。
4.  **$C_3$ 有效**：MDR $\to$ Ad(IR)。将有效地址送回IR的地址段（可选，视设计而定）。

**(3) 执行周期 (Execute Cycle)**
目标：根据有效地址取操作数，与AC相加。
1.  **$C_5$ 有效**：打开 Ad(IR) $\to$ MAR。（将有效地址送MAR）。
2.  **1 $\to$ R**：向主存发读命令。
3.  **$C_2$ 有效**：数据总线 $\to$ MDR。此时MDR里装的是**操作数**。
4.  **$C_6, C_7$ 有效**：控制ALU做加法。输入来自AC和MDR。
5.  **$C_8$ 有效**：ALU输出 $\to$ AC。结果保存。

**2. 采用 CPU 内部总线的方式 (重点)**

这种结构中，所有寄存器都挂在一条**公共的内部总线**上。

![图 9.4 采用CPU内部总线方式的数据通路和控制信号**](/img/post_article/计算机组成原理/9-4.png)

> *   **结构特点**：
>     *   所有数据传输都要经过那根竖着的总线。
>     *   **瓶颈**：同一时刻只能传一个数据（不能同时 PC$\to$MAR 和 MDR$\to$IR）。
>     *   **新增部件 Y 和 Z**（非常重要）：
>         *   **Y (暂存器)**：ALU的一个输入端。因为ALU是组合逻辑，输入必须稳定。总线一次只能传一个数，所以先把第一个数（如操作数）存到Y里，第二个数（如AC）再通过总线或者直接送过来。
>         *   **Z (暂存器)**：ALU的输出端。ALU运算结果不能直接回总线，否则会干扰正在输入的信号（产生振荡）。必须先存到Z，等稳定后再送回AC。
> *   **控制信号命名**：
>     *   $R_i$ (Input)：允许数据从总线流入寄存器R。
>     *   $R_o$ (Output)：允许数据从寄存器R流出到总线。

**详细操作流程 (ADD @X)：**

**(1) 取指周期**
1.  **$PC_o, MAR_i$**：PC内容 $\to$ 总线 $\to$ MAR。
2.  **1 $\to$ R**：读命令。
3.  **$MDR_i$**：存储器 $\to$ 数据总线 $\to$ MDR。（等待存储器读完）。
4.  **$MDR_o, IR_i$**：MDR $\to$ 总线 $\to$ IR。
5.  **PC+1**。

**(2) 间址周期**
1.  **$MDR_o, MAR_i$**：将MDR中的形式地址（或IR中的Ad） $\to$ 总线 $\to$ MAR。
2.  **1 $\to$ R**：读命令。
3.  **$MDR_i$**：存储器 $\to$ MDR。此时MDR中是**有效地址**。

**(3) 执行周期**
1.  **$MDR_o, MAR_i$**：将有效地址 $\to$ MAR。
2.  **1 $\to$ R**：读命令。
3.  **$MDR_i$**：存储器 $\to$ MDR。此时MDR中是**操作数**。
4.  **$MDR_o, Y_i$**：将操作数送入暂存器 Y。*(为ALU运算做准备)*
5.  **$AC_o, ALU_{add}, Z_i$**：AC的内容（被加数）送到总线（或直接送ALU），与Y中的内容相加，结果存入 Z。
6.  **$Z_o, AC_i$**：将Z中的结果通过总线送回 AC。

**总结：两种方式的对比**

| 特性 | 不采用内部总线 (图9.3) | 采用内部总线 (图9.4) |
| :--- | :--- | :--- |
| **硬件连接** | 寄存器间有专用通路，连线复杂 | 所有寄存器挂在一条总线上，结构简洁 |
| **并行性** | 多个数据通路可同时工作 | 同一时刻总线只能传一个数据，并行性差 |
| **ALU辅助** | 通常不需要额外暂存器 | **必须有 Y 和 Z 暂存器** |
| **应用** | 追求高性能的机器 | 追求电路简化、低成本的机器 |

**理解关键点**：
*   在内部总线结构中，凡是涉及ALU运算，通常遵循：**操作数1 $\to$ Y**，**操作数2 + Y $\to$ Z**，**Z $\to$ 结果寄存器** 的“三步走”套路。

#### 9.2.3 多级时序系统

**1. 机器周期**
*   **定义**：所有指令执行过程中的一个**基准时间**。
*   **确定依据**：通常以**访问一次存储器**的时间为基准（因为访存最慢）。若指令字长=存储字长，取指周期 = 机器周期。

**2. 时钟周期 (节拍、状态)**
*   **定义**：控制计算机操作的**最小时间单位**。
*   **关系**：一个机器周期包含若干个时钟周期（如 $T_0, T_1, T_2, T_3$）。

**3. 多级时序系统**
*   **指令周期** > **机器周期** > **时钟周期**。
*   一个指令周期包含若干机器周期（取指、间址、执行、中断）。
*   一个机器周期包含若干时钟周期。

#### 9.2.4 控制方式

即控制单元如何产生控制信号的时序。

1.  **同步控制方式**：
    *   **特点**：所有操作受统一时钟控制，步调一致。
    *   **方案**：
        *   **定长机器周期**：以最长的微操作序列为标准，短指令会有浪费。
        *   **不定长机器周期**：不同阶段分配不同数量的节拍。
        *   **中央+局部控制**：大部分统一，少数复杂操作（如乘除法）由局部节拍控制。
2.  **异步控制方式**：
    *   **特点**：无统一时钟，采用**应答方式**（Request-Acknowledge）。前一操作完成发信号，才开始下一操作。
    *   **优点**：速度快（不等待）。**缺点**：电路复杂。
3.  **联合控制方式**：
    *   **特点**：同步与异步结合。例如，CPU内部同步，访存或I/O采用异步（等待“回答”信号）。
4.  **人工控制方式**：
    *   Reset、单步执行等。

#### 9.2.5 多级时序系统实例分析 (Intel 8085)

**1. Intel 8085 的基本概况**

*   **结构**：包含控制器、运算器、寄存器组。
    *   **地址总线**：16位（$A_{15} \sim A_8$ 是高8位，$AD_7 \sim AD_0$ 是低8位）。
    *   **数据总线**：8位（与低8位地址线 **复用** $AD_7 \sim AD_0$）。
*   **外部引脚信号**（关键几个）：
    *   **CLK (Clock)**：系统时钟，一个周期就是一个 **T状态**。
    *   **ALE (Address Latch Enable)**：地址锁存允许信号。因为低8位地址和数据共用引脚，需要用ALE告诉外部：“现在总线上跑的是地址，赶紧锁存起来！”
    *   **$IO/\bar{M}$**：区分是访问I/O设备还是访问存储器（高电平IO，低电平Mem）。
    *   **$\overline{RD}$ / $\overline{WR}$**：读/写控制信号（低电平有效）。

**2. 时序系统的组成**

*   **指令周期**：执行一条指令的时间。包含 1~5 个 **机器周期**。
*   **机器周期**：完成一个基本操作（如取指、读存、写I/O）的时间。包含 3~5 个 **T状态**。
*   **T状态 (节拍)**：时钟的一个周期。

**3. 实例：OUT 指令的执行过程**

**指令格式**：`OUT port` (双字节指令)
*   **字节1**：操作码。
*   **字节2**：I/O端口地址（8位）。
*   **功能**：把累加器(AC)里的数据写到指定的I/O端口去。

该指令需要 **3个机器周期 (M1, M2, M3)** 来完成。

![图 9.4 8085输出指令时序图](/img/post_article/计算机组成原理/9-4.png)

> *   **描述**：图中展示了CLK波形，以及对应的地址线、控制信号在M1, M2, M3期间的变化。

**详细流程解析：**

**第一阶段：M1 机器周期 (取指令)**
*   **任务**：从内存取操作码。
*   **时长**：4个T状态 ($T_1 \sim T_4$)。
*   **细节**：
    *   **$T_1$**：
        *   **PC $\to$ 总线**：PC的高8位送 $A_{15} \sim A_8$，低8位送 $AD_7 \sim AD_0$。
        *   **ALE 信号**：发出一个脉冲，告诉外部电路“现在 $AD$ 线上是地址，快存起来”，防止后面传数据时地址丢了。
        *   **$IO/\bar{M} = 0$**：表示要访问存储器。
    *   **$T_2$**：
        *   **$\overline{RD}$ 有效**：CPU命令存储器“读”。
        *   PC计数器 + 1。
    *   **$T_3$**：
        *   **数据 $\to$ 指令寄存器**：存储器把操作码放到数据总线上，CPU读入并送往IR。
    *   **$T_4$**：
        *   **译码/执行**：CPU内部对操作码进行译码，知道这是个OUT指令。

**第二阶段：M2 机器周期 (读端口地址)**
*   **任务**：从内存取指令的第二个字节（端口号）。
*   **时长**：3个T状态 ($T_1 \sim T_3$)。
*   **细节**：
    *   **$T_1$**：PC（现在指向第二字节）送出地址。ALE有效。
    *   **$T_2$**：$\overline{RD}$ 有效。
    *   **$T_3$**：
        *   **取地址**：存储器把端口号送过来，CPU把它暂存在内部寄存器（W, Z）中。
        *   *注意*：这一步只是把“要往哪里写”这个地址拿到了，还没开始写。

**第三阶段：M3 机器周期 (写I/O)**
*   **任务**：把AC的数据写真正的I/O端口。
*   **时长**：3个T状态 ($T_1 \sim T_3$)。
*   **细节**：
    *   **$T_1$**：
        *   **送地址**：CPU把刚才拿到的端口号送到地址总线上。
        *   **$IO/\bar{M} = 1$**：**关键点**，信号变高了，表示这次是玩I/O设备，不是玩内存。
    *   **$T_2$**：
        *   **$\overline{WR}$ 有效**：CPU发出“写”命令。
        *   **送数据**：CPU把累加器(AC)的数据扔到数据总线上。
    *   **$T_3$**：
        *   **写入**：$\overline{WR}$ 撤销，数据在下降沿被I/O设备写入。指令结束。

**总结**

通过8085的这个例子，我们可以看到：
1.  **控制信号是有时间顺序的**：不是一股脑全发出去，而是配合时钟（CLK）和机器周期（M1, M2...）按部就班地发。比如先发ALE锁地址，再发RD读数据。
2.  **微操作的具体化**：第9.1节讲的抽象的 `PC -> MAR`，在这里变成了具体的 `PC -> 地址引脚` 和 `ALE信号有效`。
3.  **状态区分**：CPU通过不同的机器周期（M1取指，M2读存，M3写IO）和状态信号（$IO/\bar{M}$）来区分当前在干什么。

## 第10章 控制单元的设计

本章的核心内容是**如何设计控制单元 (CU)**。控制单元的作用是产生微操作命令（控制信号），指挥计算机各部件协同工作。设计方法主要有两种：**组合逻辑设计**（硬连线逻辑）和**微程序设计**（存储逻辑）。

### 10.1 组合逻辑设计

#### 10.1.1 组合逻辑控制单元框图

![图 10.1 带译码和节拍输入的控制单元框图](/img/post_article/计算机组成原理/10-1.png)

> *   **输入**：
>     1.  **指令操作码**：来自指令寄存器IR，经过**指令译码器**译码，产生 $2^n$ 个输出，对应不同指令。
>     2.  **时钟节拍**：来自**节拍发生器**，产生 $T_0, T_1, \dots, T_n$ 等节拍信号，控制微操作的先后顺序。
>     3.  **标志**：来自执行部件反馈的状态信号（如进位、零标志）。
> *   **处理核心**：**CU**（组合逻辑电路）。
> *   **输出**：控制信号 $C_0, C_1, \dots, C_n$，控制CPU内部寄存器传输和系统总线操作。

**设计思想**：控制信号 $C_i$ 是关于操作码、节拍和标志的逻辑函数。即 $C_i = f(OP, T, Flag)$。

#### 10.1.2 微操作的节拍安排

在组合逻辑设计中，我们需要硬性规定每个机器周期包含多少个节拍（假设为3个：$T_0, T_1, T_2$），并把具体的微操作安插到这些节拍里。

**前提假设**：
*   采用同步控制。
*   硬件结构如图9.3所示（非总线结构，寄存器间有独立通路）。
*   安排原则：
    1.  **顺序不能乱**：必须先送地址，才能读数据。
    2.  **能并行的尽量并行**：比如“数据读入MDR”和“PC+1”互不干扰，可以同时做。
    3.  **速度快的合并**：比如译码速度很快，可以和数据传送放在同一拍。

**1. 取指周期 (Fetch Cycle)** - 公共操作
所有指令都要经历这个过程，把指令从内存搬到IR。
*   **$T_0$**: $PC \to MAR, 1 \to R$
    *   *理解*：把PC里的地址送到MAR，告诉主存“我要读这个地址”，并发出读命令。
*   **$T_1$**: $M(MAR) \to MDR, (PC)+1 \to PC$
    *   *理解*：主存把数据吐出来放到MDR里；同时PC加1，指向下一条指令（为下一步做准备）。
*   **$T_2$**: $MDR \to IR, OP(IR) \to ID$
    *   *理解*：把指令搬到指令寄存器IR，同时操作码送去译码。

**2. 间址周期 (Indirect Cycle)**
如果指令是间接寻址，还得去内存找数据的真实地址。
*   **$T_0$**: $Ad(IR) \to MAR, 1 \to R$
    *   *理解*：把指令里的形式地址送MAR，发读命令。
*   **$T_1$**: $M(MAR) \to MDR$
    *   *理解*：读出来的不是操作数，而是有效地址，暂存MDR。
*   **$T_2$**: $MDR \to Ad(IR)$
    *   *理解*：把有效地址送回IR的地址字段（更新一下），方便后面执行。

**3. 执行周期 (Execute Cycle)** - 视指令而定
这里以那10条典型指令为例：

**(1) 非访存指令**（不需要访问内存，操作很快）
*   **CLA (清零ACC)**:
    *   $T_2$: $0 \to AC$ （可以在最后一下完成，前两拍空闲）。
*   **COM (取反)**:
    *   $T_2$: $\overline{AC} \to AC$。
*   **SHR (算术右移)**:
    *   $T_2$: $L(AC) \to R(AC), AC_0 \to AC_0$ （符号位不变）。
*   **CSL (循环左移)**:
    *   $T_2$: $R(AC) \to L(AC), AC_0 \to AC_n$。
*   **STP (停机)**:
    *   $T_2$: $0 \to G$ （G是运行标志，置0就停机）。

**(2) 访存指令**（需要读写内存，要用满3个节拍）
*   **ADD X (加法)**:
    *   $T_0$: $Ad(IR) \to MAR, 1 \to R$ （送地址，读命令）。
    *   $T_1$: $M(MAR) \to MDR$ （数据读进MDR）。
    *   $T_2$: $(AC) + (MDR) \to AC$ （运算，结果回AC）。
*   **STA X (存数)**:
    *   $T_0$: $Ad(IR) \to MAR, 1 \to W$ （送地址，**写**命令）。
    *   $T_1$: $AC \to MDR$ （把AC里的数据送到MDR准备写入）。
    *   $T_2$: $MDR \to M(MAR)$ （真正写入内存）。
*   **LDA X (取数)**:
    *   $T_0$: $Ad(IR) \to MAR, 1 \to R$。
    *   $T_1$: $M(MAR) \to MDR$。
    *   $T_2$: $MDR \to AC$ （数据从MDR搬到AC）。

**(3) 转移类指令**
*   **JMP X (无条件跳转)**:
    *   $T_2$: $Ad(IR) \to PC$ （直接把指令里的地址给PC，下次就从这儿取指）。
*   **BAN X (条件跳转 - 负则转)**:
    *   $T_2$: $A_0 \cdot Ad(IR) + \overline{A_0} \cdot (PC) \to PC$。
    *   *理解*：如果$A_0$（符号位）是1（负数），就把跳转地址给PC；如果是0（正数），PC保持不变（其实在取指阶段已经+1了，所以就是顺序执行）。

#### 10.1.3 组合逻辑设计步骤

**1. 列出操作时间表**
列出所有指令在各个节拍下的微操作命令。

![表 10.1 操作时间表](/img/post_article/计算机组成原理/Table10-1.png)

> *   表格纵向是时间（取指、间址、执行周期的各个节拍），横向是各种指令。表中“1”表示该指令在该节拍需要产生对应的控制信号。

**2. 写出微操作命令的逻辑表达式**
根据操作时间表，将产生某个控制信号的所有条件（指令+节拍）进行逻辑“或”组合。
例如，控制信号 **$M(MAR) \to MDR$** 在以下情况需要有效：
*   取指周期的 $T_1$ (所有指令)。
*   间址周期的 $T_1$ (所有指令)。
*   执行周期的 $T_1$ (仅对于ADD, LDA指令)。

表达式：
$$ M(MAR) \to MDR = FE \cdot T_1 + IND \cdot T_1 + EX \cdot T_1 \cdot (ADD + LDA) $$
（其中FE, IND, EX是周期标志，ADD, LDA是指令译码信号）

**3. 画出逻辑图**
根据布尔表达式画出与或非门电路。

![图 10.3 产生 M(MAR)->MDR 命令的逻辑图](/img/post_article/计算机组成原理/10-3.png)

**优缺点**：
*   **优点**：速度快（直接由门电路产生）。
*   **缺点**：设计复杂，电路庞杂，修改困难（牵一发而动全身）。**RISC**通常采用此方法。

### 10.2 微程序设计

#### 10.2.1 微程序设计思想的产生

**核心思想**：仿照程序设计的方法，将一条机器指令编写成一段**微程序**。微程序由若干条**微指令**组成，微指令包含若干**微操作控制信号**。

#### 10.2.2 微程序控制单元框图及工作原理

**1. 基本概念**
*   **微命令**：控制部件向执行部件发出的各种控制信号（如打开门、ALU加）。
*   **微操作**：微命令的执行过程。
*   **微指令**：一组微命令的集合。通常包含**操作控制**（发命令）和**顺序控制**（指明下一条微指令地址）两部分。
*   **微程序**：实现一条机器指令功能的微指令序列。

**2. 存储位置**
微程序存放在**控制存储器 (CM/CS)** 中。CM通常用**ROM**实现（只读，速度快）。

**3. 基本框图**

![图 10.5 微程序控制单元的基本组成](/img/post_article/计算机组成原理/10-5.png)

> *   **CMAR (控存地址寄存器)**：存放微指令的地址。
> *   **CM (控制存储器)**：存放微程序。
> *   **CMDR (控存数据寄存器)**：存放从CM读出的微指令（又称**μIR**）。
> *   **微地址形成部件**：根据机器指令的操作码(OP)，产生对应微程序的入口地址。
> *   **顺序逻辑**：控制微指令的执行顺序（如PC+1或分支跳转）。

**4. 工作过程**
1.  **取机器指令**：执行公用的“取指微程序”。
2.  **转微程序入口**：将IR中的操作码送入“微地址形成部件”，产生该机器指令对应的微程序首地址，送入CMAR。
3.  **执行微程序**：从CM中逐条取出微指令，执行微操作，直到结束，再回到取指微程序。

#### 10.2.3 微指令的编码方式

如何用二进制位表示控制信号？

**1. 直接编码 (直接控制)**
*   **方法**：微指令的每一位代表一个控制信号（1有效，0无效）。
*   **优点**：简单直观，并行性好，速度快。
*   **缺点**：微指令字太长（有多少个控制信号就要多少位）。

![图 10.7 直接编码方式](/img/post_article/计算机组成原理/10-7.png)

**2. 字段直接编码 (显式编码)**
*   **方法**：将微指令的操作控制字段分成若干段，每段译码后产生一个微命令。
*   **原则**：互斥的命令分在同一段，相容（并行）的命令分在不同段。
*   **优点**：缩短了字长。
*   **缺点**：增加了译码延迟。

![图 10.8 字段直接编码方式](/img/post_article/计算机组成原理/10-8.png)

**3. 字段间接编码 (隐式编码)**
*   **方法**：一个字段的含义由另一个字段解释。
*   **特点**：进一步缩短字长，但控制复杂，速度慢。

#### 10.2.4 微指令的地址形成

如何确定下一条微指令的地址？

1.  **下地址字段指出**：微指令中直接包含下一条地址（断定方式）。
2.  **操作码形成**：机器指令操作码 $\to$ 微地址形成部件 $\to$ 微程序入口地址。
3.  **增量计数**：`(CMAR) + 1 -> CMAR`。
4.  **分支转移**：根据状态标志（如进位、零）修改下地址，实现微程序跳转。

#### 10.2.5 微指令格式

**1. 水平型微指令**
*   **特点**：一次能定义并执行多个并行操作。
*   **代表**：直接编码、字段直接编码。
*   **优缺点**：并行能力强，效率高，灵活；但指令长，编写难。

**2. 垂直型微指令**
*   **特点**：采用类似机器指令的操作码，一条微指令只能完成1~2个操作（如 `MOV A, B`）。
*   **优缺点**：指令短，易编写；但并行性差，执行速度慢。

**对比**：
*   水平型：**微指令长**，微程序**短**，速度**快**。
*   垂直型：**微指令短**，微程序**长**，速度**慢**。

#### 10.2.6 静态与动态微程序设计
*   **静态**：微程序固化在ROM中，不可修改。
*   **动态**：微程序存放在EPROM或RAM中，可以通过改变微指令来改变机器指令系统（如仿真）。

#### 10.2.7 毫微程序设计
*   **两级微程序**：微程序解释机器指令，毫微程序解释微指令。
*   **结构**：微指令作为“机器指令”，毫微指令作为“微指令”。
*   **优点**：进一步压缩控制存储器容量。

#### 10.2.8 串行与并行微程序控制
*   **串行**：取微指令 $\to$ 执行微指令 $\to$ 取下一条...
*   **并行**：在执行当前微指令的同时，预取下一条微指令（流水线思想）。需增加 **微指令寄存器**。

#### 10.2.9 微程序设计举例

这一节通过一个具体的例子，展示如何从零开始设计一个微程序控制器。
**任务**：设计上述10条机器指令的微程序。

**设计步骤详解：**

**第一步：写出对应机器指令的微操作及节拍安排**
这里要把机器指令的操作分解成微指令。

*   **取指阶段 (公共微程序)**：
    *   微指令1：$PC \to MAR, 1 \to R$
    *   微指令2：$M(MAR) \to MDR, (PC)+1 \to PC$
    *   微指令3：$MDR \to IR, OP(IR) \to \text{微地址形成部件}$
*   **执行阶段 (以ADD为例)**：
    *   微指令4：$Ad(IR) \to MAR, 1 \to R$
    *   微指令5：$M(MAR) \to MDR$
    *   微指令6：$(AC)+(MDR) \to AC$
    *   *注*：执行完后通常要回到微指令1（取下一条指令）。

**第二步：确定微指令格式**

1.  **编码方式**：
    *   为了简单，采用**直接编码**（一位代表一个控制信号）。
    *   统计发现共需要20个微操作控制信号，所以**操作控制字段**至少20位。
2.  **下地址形成方式**：
    *   **断定方式**：由微指令的**下地址字段**直接给出。
    *   **操作码译码**：取指结束后，根据机器指令的操作码(OP)跳转到对应的执行微程序首地址。
3.  **微指令字长**：
    *   操作控制字段 (20位) + 下地址字段 (假设需要6位，能寻址64条微指令) = 26位。
4.  **优化 (关键点)**：
    *   书在这一节提出了一个**流水线式**的优化思路：
    *   原方案：取指需3条微指令，因为每一步都要等下地址形成。
    *   **改进方案**：将 `Ad(CMDR) -> CMAR` （下地址送控存地址寄存器）这个操作通过硬件直接连线，在时钟上升沿自动完成。
    *   **结果**：取指微程序可以缩短，实际上微指令的读取和执行可以重叠。

![图 10.16 省去了 CMAR 的控制存储器](/img/post_article/计算机组成原理/10-16.png)

> *   **描述**：直接用 CMDR 中的下地址字段指向下一条微指令，或者通过多路选择器选择由 OP 译码产生的地址。这样省去了一个中间寄存器打入的时间。

**优化后的微指令格式**：
*   **操作控制字段 (24位)**：预留了一些扩展位。
*   **下地址字段 (6位)**：用于指向下一条微指令。
*   **总字长**：30位。

![图 10.17 对应10条机器指令的微指令格式](/img/post_article/计算机组成原理/10-17.png)

**第三步：编写微指令码点**
这就是“填表”工作。把每一条微指令对应的控制信号位置“1”，其他置“0”，并填好下一条微指令的地址。

![表 10.3 对应10条机器指令的微指令码点](/img/post_article/计算机组成原理/Table10-3.png)

> *   **解读**：
>     *   **取指微程序**：地址00~02。执行完后跳转方式比较特殊，是根据IR中的操作码跳转（表中用 $x \dots x$ 表示）。
>     *   **ADD指令微程序**：地址10~12。执行完后，下地址填00（回到取指）。
>     *   **JMP指令**：地址21。直接把地址送PC，然后下地址填00。

**总结这个例子的核心逻辑**：
1.  **拆解**：把机器指令拆成微操作。
2.  **打包**：把能同时做的微操作打包成一条微指令。
3.  **链接**：通过下地址字段，把微指令像链表一样串起来，形成微程序。
4.  **分支**：在取指结束时，利用操作码映射（MAP）实现多路分支，跳到对应的执行微程序去。