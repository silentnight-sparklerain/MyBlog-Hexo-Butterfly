---
title: 计算机组成原理（3）：中央处理器
categories:
  - Programming
  - Theory
comments: true
description: 计算机组成原理第三部分：中央处理器
series: 计算机组成原理笔记
hide: true
mathjax: false
katex: true
highlight_shrink: true
cover: /img/posts/计算机组成原理.png
abbrlink: 5c14eb1b
date: 2025-12-21 00:00:00
updated: 2025-12-21 00:00:00
keywords:
top_img:
aside:
aplayer:
---

## 第6章 计算机的运算方法

本章核心：计算机内部如何表示数据（有符号/无符号、定点/浮点），以及如何进行加减乘除运算。

### 6.0 （补充）非数值数据的表示、数据信息的校验

#### 6.0.1 字符表示

*   **非数值数据**：没有数值大小之分，如字符和汉字等。
*   **ASCII码**：使用7bit表示128个字符（从000 0000 到 111 1111）。计算机中数据存储以字节为单位，故字节最高位（Most Significant Bit，MSB ）为0。**单字节编码**。

[ASCII码 - 官网](https://www.ascii-code.com/)
[ASCII码 - 菜鸟驿站](https://www.runoob.com/w3cnote/ascii.html)

#### 6.0.2 汉字编码

*   **汉字输入码**：使用英文键盘输入汉字时所使用的编码（输入法：将从键盘输入的汉字输入码转化为汉字的机器内码）。
*   **汉字交换码**：不同的具有汉字处理功能的计算机系统之间在交换汉字信息时所用的代码标准：国标码。
*   **区位码**：
    *   为检索方便，采用94X94=8836的二维矩阵对汉字、特殊符号、数字、英文字符、制表符等进行编码。
    *   每一行称为“区”，每一列称为“位”，编号从1开始。
    *   区号和位号的组合（**4位10进制**）构成该字的区位码。比如“中”（区位码）：5448。
    *   **双字节编码**
    *   同一英文字母、数字和符号：在区位码中以两个字节表示，称之为**全角字符**，在ASCII码中以一个字节表示，称之为**半角字符**，在屏幕上的显示宽度为全角字符的一半。例如：A（区位码）：0333；A（ASCII码）：01000001。
*   **国标码**：
    *   为了复用ASCII码中的控制码（0~31）、空格字符（32）且不发生冲突，将区位码的区号和位号分别加上32（20H）得到国标码。
    *   **国标码 = 区位码 + 2020H**。例如：中（国标码）：5650H=3630H（区位码）+2020H。
*   **汉字机内码**：
    *   计算机内部存储、处理汉字时所用的统一编码。
    *   国标码前后字节的最高位为0，与ASCII码发生冲突。例如：中：5650H误认为V（56H）和P（50H）。
    *   ASCII码MSB为0，汉字机内码MSB为1。
    *   **汉字机内码 = 汉字国标码 + 8080H**。例如：中（机内码） ：D6D0H= 5650H（国标码） +8080H。
*   **汉字字形码（汉字字模）**：
    *   表示汉字字形信息（结构、形状、笔画等）的编码，以实现计算机对汉字的输出（显示、打印）。最常用的表示方式：点阵形式和矢量形式。
    *   **点阵形式**：
        *   将字符的字形分解成若干“点”组成的点阵，有字形笔画的点用黑色，反之用白色。在存储时，用1表示黑色点，0表示没有笔画的白色点，顺序存储，即构成汉字字形码。
        *   **占用存储空间大**，以32×32为例：每个汉字要占用128个字节（1字节=8位）。
        *   只用来构成汉字库，不用于机内存储， 需要时才到字库中检索汉字并输出。
        *   不同字体（如黑体、微软雅黑等）对应不同的汉字库。
    *   **矢量形式**：
        *   通过直线、曲线来描述每一个汉字字形。存储这些线的关键点。利用这些点来绘制曲线或直线，描绘出字体的轮廓，最后进行黑色填充。
        *   二次贝塞尔曲线。
    *   两种表示形式对比：
        *   点阵形式输出的字体放大后会变形。
        *   矢量形式描述的字形与最终文字显示的大小、分辨率无关，放大或缩小字体的时候，只需要按比例缩放改变端点值的相对位置，故可以输出高质量的字形。

#### 6.0.3 数据信息的校验

*   **码距与校验**
    *   **必要性**：数据在处理、传输和存储过程中，受元器件质量、电路故障或噪音干扰，可能出现错误。
    *   **校验码原理**：在原始数据中引入冗余信息（校验位），增加**码距**，使编码符合特定规则。若规则被破坏，则说明发生错误。
    *   **码距 (Hamming Distance)**：
        *   指两个编码对应二进制位不同的个数。
        *   **最小码距**：同一编码系统中，任意两个合法编码之间码距的最小值。
        *   **作用**：最小码距为1时无检错能力；增大到2时可检测一位错误。码距越大，抗干扰和纠错能力越强，但编码效率会降低。

*   **奇偶校验** (Parity Check)
    *   **基本原理**：在原始数据位（$k$位）的基础上增加1位校验位（$P$），使码距变为2。
    *   **分类**：
        *   **奇校验**：编码中“1”的个数为奇数。
        *   **偶校验**：编码中“1”的个数为偶数。
    *   **实现方式**：利用异或（XOR）逻辑电路生成校验位。
    *   **性能特点**：
        *   **优点**：实现简单，编码效率高。
        *   **缺点**：只能检测出**奇数位**错误，**不能纠错**，也不能发现偶数位错误。

*   **海明校验** (Hamming Check)
    *   **核心特点**：具有**一位纠错**能力。
    *   **工作原理**：
        *   采用**分组校验**和**非划分方式**（即数据位交叉属于多个校验组）。
        *   通过多个校验组生成的“检错码”（Syndrome）来精确定位出错位的位置。
    *   **配置规则**：
        *   **校验位数量 ($r$)**：需满足关系式 $2^r \ge k + r + 1$（$k$为数据位）。
        *   **位置分布**：校验位通常放置在海明码中编号为 $2^i$（如1, 2, 4, 8...）的位置。
        *   **分组逻辑**：每一位数据位由其编号分解出的校验位共同校验（例如第3位由第1位和第2位校验位负责）。
    *   **检错与纠错过程**：
        *   接收方重新计算各组的校验情况，生成检错码 $G_r...G_2G_1$。
        *   若检错码为0，表示无错误；若不为0，其二进制值直接指出出错位的编号。
        *   定位错误后，通过取反即可实现自动纠错（如果是数据位出错）。

![图 6.0 海明码纠错](/img/post_article/计算机组成原理/6-0.png)

### 6.1 无符号数和有符号数

计算机中的数据放在寄存器中，寄存器的位数称为机器字长。

#### 6.1.1 无符号数
*   **定义**：没有符号的数，寄存器的每一位都用来存放数值。
*   **范围**：如果机器字长为8位，范围是 $0 \sim 2^8-1$ (即 $0 \sim 255$)。

#### 6.1.2 有符号数
*   **真值**：带有“+”或“-”符号的实际数值（如 +1011, -1011）。
*   **机器数**：把符号“数字化”后的数。通常用“0”表示正，“1”表示负。
*   **四种编码方式**：

**1. 原码 (Sign-Magnitude)**
*   **定义**：符号位（0正1负）+ 绝对值。
*   **举例**（8位字长）：
    *   $x = +1011 \rightarrow [x]_{原} = 00001011$
    *   $x = -1011 \rightarrow [x]_{原} = 10001011$
*   **特点**：
    *   简单直观。
    *   **0有两种表示**：$[+0]_{原} = 00000000$, $[-0]_{原} = 10000000$。
    *   加减运算复杂（需判断符号，可能变减法）。

**2. 补码 (Two's Complement)**
*   **引入目的**：将减法变为加法（模运算原理），解决负数加法问题。
*   **定义**：
    *   **正数**：与原码相同。
    *   **负数**：原码符号位不变，数值位**按位取反，末位加1**。
*   **举例**：
    *   $x = -1011 \rightarrow [x]_{原}=1,1011 \rightarrow \text{取反} 1,0100 \rightarrow \text{加1} \rightarrow [x]_{补}=1,0101$
*   **特点**：
    *   **0只有一种表示**：$[+0]_{补} = [-0]_{补} = 00000000$。
    *   能多表示一个负数（如8位补码范围 -128 ~ +127，原码是 -127 ~ +127）。
    *   **[y]补 求 [-y]补**：连同符号位在内，每位取反，末位加1。

**3. 反码 (One's Complement)**
*   **定义**：
    *   **正数**：与原码相同。
    *   **负数**：原码符号位不变，数值位**按位取反**。
*   **特点**：
    *   0有两种表示。
    *   通常作为求补码的中间状态。

**4. 移码 (Excess-N)**
*   **定义**：$[x]_{移} = 2^n + x$ （$2^n$为偏置值，通常针对阶码）。
*   **特点**：
    *   移码和补码仅**符号位相反**，数值位相同。
    *   **保持了数据的大小顺序**（方便比较大小，如浮点数的阶码比较）。
    *   0只有一种表示：$100\dots0$。

### 6.2 数的定点表示和浮点表示

#### 6.2.1 定点表示 (Fixed-Point)
*   **定义**：小数点固定在某一位置。
定点数的小数点位置是固定的。
*   **定点小数**：小数点固定在符号位和第一数值位之间。
    *   格式：`符号 . 数值`
    *   范围（原码）：$-(1 - 2^{-n}) \sim +(1 - 2^{-n})$
    *   范围（补码）：$-1 \sim +(1 - 2^{-n})$ 
*   **定点整数**：小数点固定在数值位最后。
    *   格式：`符号 数值 .`
    *   范围（原码）：$-(2^n - 1) \sim +(2^n - 1)$
    *   范围（补码）：$-2^n \sim +(2^n - 1)$。
*   **特点**：范围受限，容易溢出。

#### 6.2.2 浮点表示 (Floating-Point)
*   **格式**：$N = S \times r^j$
    *   **S (尾数)**：纯小数，决定精度。通常用补码或原码。
    *   **j (阶码)**：整数，决定范围。通常用移码或补码。
    *   **r (基数)**：通常为2（隐含）。
浮点数 $N = S \times r^j$。
    *   **最大正数**：阶码最大正数，尾数最大正数。
    $$2^{(2^m-1)} \times (1-2^{-n})$$
    *   **最小正数**：阶码最小负数，尾数最小正数（规格化）。
    $$2^{-(2^m-1)} \times 2^{-1}$$
    *   **最大负数**：阶码最小负数，尾数最大负数（规格化）。
    $$- [2^{-(2^m-1)} \times 2^{-1}]$$
    *   **最小负数**：阶码最大正数，尾数最小负数。
    $$- [2^{(2^m-1)} \times (1-2^{-n})]$$
    *   **上溢**：阶码 $> \text{Max}$。机器停止运算，报错。
    *   **下溢**：阶码 $< \text{Min}$。机器当作0处理（机器零）。
*   **规格化**：为了提高精度，规定尾数最高有效位必须为非0（对于二进制，即0.1xxxx）。
    *   **左规**：尾数左移，阶码减。
    *   **右规**：尾数右移，阶码加（防止溢出）。
*   **IEEE 754 标准**（重要）：
    *   格式：**符号位(1) + 阶码(8/11) + 尾数(23/52)**。
    *   **短实数(32位)**：阶码偏移量127。
    *   **隐藏位**：尾数形式为 `1.fffff`，整数部分的“1”隐含不存，节省一位。

#### 6.2.3 定点数和浮点数的比较
*   浮点范围大、精度高，但运算复杂，硬件成本高。
*   定点运算速度快，成本低，但范围小。

#### 6.2.4 举例 (例 6.6)

**题目**：设浮点数字长16位，阶码5位（含1位阶符），尾数11位（含1位数符）。写出 $- \frac{53}{512}$ 的浮点数规格化形式。要求：阶码用移码，尾数用补码。

**解题步骤**：
1.  **转二进制**：
    $53 = 110101$
    $\frac{53}{512} = \frac{110101}{2^9} = 0.000110101$
    $x = -0.000110101$
2.  **规格化**：
    $x = -0.110101 \times 2^{-3}$
    即：尾数 $S = -0.110101$，阶码 $j = -3$。
3.  **求阶码的移码**：
    $j = -3 = -0011$
    阶码位数为5（含符号），数值位4位，偏置值为 $2^4 = 10000$。
    $[j]_{移} = 2^4 + j = 10000 - 0011 = 01101$
4.  **求尾数的补码**：
    $S = -0.110101$
    $[S]_{原} = 1.1101010000$ （补齐10位数值）
    $[S]_{补} = 1.0010110000$
5.  **组合**：
    **01101, 1.0010110000**
    (注意：题目若要求阶码移码，尾数补码，则结果如上。若题目是其他组合，按相应规则转换)

#### 6.2.5 IEEE 754 标准

IEEE 754 是现代计算机最通用的浮点数标准。
**格式**：`符号位S (1位)` + `阶码 (移码)` + `尾数 (原码)`

**1. 三种精度**
*   **短实数 (32位)**：S(1) + 阶(8) + 尾(23)。偏置值 **127**。
*   **长实数 (64位)**：S(1) + 阶(11) + 尾(52)。偏置值 **1023**。
*   **临时实数 (80位)**：S(1) + 阶(15) + 尾(64)。

**2. 关键特性**
*   **隐藏位**：尾数规格化形式为 `1.ff...f`。那个整数部分的`1`是隐含的，不占位数，从而多存一位精度。
*   **阶码**：使用移码，但偏置值是 $2^{k-1}-1$（而非 $2^{k-1}$）。
    *   例如8位阶码，偏置值是 $127$ ($01111111$)。
    *   阶码真值 $e$，移码 $E = e + 127$。

### 6.3 定点运算

#### 6.3.1 移位运算
*   **算术移位**（针对有符号数）：
    *   **正数**：移位补0。
    *   **负数（补码）**：**左移补0，右移补1**（保持符号位不变）。
    *   **负数（原码）**：移位补0。
    *   **负数（反码）**：移位补1。
*   **逻辑移位**（针对无符号数）：
    *   不论左右移，空位一律**补0**。

#### 6.3.2 加法与减法运算 (补码)

**1. 采用补码运算的原因**

*   用原码作加减法运算的问题：需要根据操作数的符号，确定作加法还是减法，并设计、使用加法器/减法器，±0原码不统一。
*   用反码作加减法运算的问题：电路实现较麻烦，±0反码不统一。
*   用补码作加减法运算：找到一个与负数等价的正数来代替负数，实现了加减法形式的统一。±0补码统一。

**2. 运算公式**
*   **加法**：$[A+B]_{补} = [A]_{补} + [B]_{补}$
*   **减法**：$[A-B]_{补} = [A]_{补} + [-B]_{补}$
*   **注意**：符号位与数值位一起参与运算，符号位产生的进位要丢弃。

**3. 溢出判断**
在定点机中，只有**正数加正数**或**负数加负数**才可能产生溢出。
*   **方法一：一位符号位判别法**
    *   如果参加运算的两个数符号相同（同正或同负），而结果的符号与它们不同，则发生溢出。
    *   *逻辑表达式*：$V = A_s B_s \overline{S_s} + \overline{A_s} \overline{B_s} S_s$ （A、B为操作数符号，S为结果符号）。
*   **方法二：双符号位判别法 (变形补码)** 
    *   使用两位符号位：**00** 表示正，**11** 表示负。
    *   **01**：表示**正溢出**（上溢）。
    *   **10**：表示**负溢出**（下溢）。
    *   运算时，最高符号位代表真正的符号。

**4. 实例演示 (例 6.16)**

**题目**：已知 $x = -\frac{11}{16}, y = -\frac{7}{16}$，用**变形补码**计算 $x+y$，并判断是否溢出。

**解题步骤**：

**(1) 转二进制**：
$$x = -0.1011, \quad y = -0.0111$$

**(2) 求变形补码 (双符号位)**：
*   $[x]_{补} = 11.0101$
*   $[y]_{补} = 11.1001$

**(3) 相加运算**：

```text
    11.0101    ([x]补)
+   11.1001    ([y]补)
-----------
  1 10.1110
```
*   **注意**：最高位的进位 `1` 直接丢弃（模 $2^{n+2}$）。
*   **运算结果**：`10.1110`

**(4) 判断溢出**：
*   结果的双符号位为 **`10`**。
*   根据规则：`10` 表示**负溢出**。
*   (注：最高位 `1` 代表真正的符号是负数，`0` 表示数值部分破坏了符号位)。

**结论**：计算结果溢出。

**5. 补码加减法的硬件配置**
*   𝑛 + 1位加法器，增加溢出判断（单符号位）。

![图 6.3.2-1 𝑛 + 1位加法器](/img/post_article/计算机组成原理/6.3.2-1.png)

*   寄存器A、X 、加法器均 𝑛 + 1 位（1位符号位，𝑛位数值位）。
*   A：被加数（或被减数）的补码， X：加数（或减数）的补码。
*   $G_A$：加法标记 ，$G_S$：减法标记，V：溢出标记
*   当作减法时，用减法标记 $G_S$ 控制求补逻辑，将$\overline{X}$送至加法器，同时使加法器的最末位外来进位为1，来求减数的补码。

![图 6.3.2-2 补码定点加减法的硬件配置](/img/post_article/计算机组成原理/6.3.2-2.png)

#### 6.3.3 乘法运算
*   **原码一位乘法**：
    *   符号位单独处理（异或）。
    *   数值部分绝对值相乘。
    *   **规则**：
        *   乘数末位=1，部分积+被乘数，右移。
        *   乘数末位=0，部分积+0，右移。
        *   移位是**逻辑右移**。
    * **算法规则**：
        *   **符号位**：单独处理，异或运算。$S_p = S_x \oplus S_y$。
        *   **数值位**：绝对值相乘。
    *   **运算过程**：
        *   看乘数最低位 $y_n$。
        *   若 $y_n=1$，部分积加上被乘数 $|x|$；若 $y_n=0$，部分积加0。
        *   部分积和乘数**右移一位**。
        *   重复 $n$ 次。

![图 6.3.3-1 原码一位乘法例题图1](/img/post_article/计算机组成原理/6.3.3-1.png)
![图 6.3.3-2 原码一位乘法例题图2](/img/post_article/计算机组成原理/6.3.3-2.png)

*   **原码一位乘法的硬件配置**：
    *   寄存器A、X、Q、加法器均 𝑛 + 1 位
    *   A：部分积的高位，最高位非符号位，而是低位数值部分相加后向高位的进位。
    *   X：被乘数的原码。
    *   Q（MQ）：乘数的原码、部分积的低位。
    *   计数器C（计数器值 = 移位次数 = 数值部分位数 = 𝑛，每移位一次，计数器值减1）
    *   S：乘积符号
    *   $G_M$：乘法标志

![图 6.3.3-3 原码一位乘法的硬件配置](/img/post_article/计算机组成原理/6.3.3-3.png)

*   **补码一位乘法 (Booth算法)**：
    *   符号位参与运算。
    *   **规则**：取决于乘数末两位 $(y_{n}, y_{n+1})$。
        *   `00` 或 `11`：右移一位。
        *   `01`：部分积 + $[x]_{补}$，右移。
        *   `10`：部分积 + $[-x]_{补}$，右移。
    *   移位是**算术右移**。

#### 6.3.4 原码除法

符号位单独异或处理。数值部分用绝对值相除。

**1. 恢复余数法**
*   **思路**：先默认够减（上商1，做减法）。
*   **判断**：
    *   如果余数为正：说明够减，商1正确，左移余数，继续。
    *   如果余数为负：说明不够减，商0。**必须把除数加回来**（恢复余数），然后再左移。
*   **缺点**：步骤多，速度慢（最坏情况要做2n次加法）。

![图 6.3.4-1 恢复余数法例题图1](/img/post_article/计算机组成原理/6.3.4-1.png)
![图 6.3.4-2 恢复余数法例题图2](/img/post_article/计算机组成原理/6.3.4-2.png)

**2. 加减交替法 (不恢复余数法)**
*   **思路**：余数为负时不恢复，直接左移，然后**加**除数。
*   **规则**：
    *   余数 $R_i > 0$：商1，左移，**减**除数。
    *   余数 $R_i < 0$：商0，左移，**加**除数。
*   **优点**：步数固定（n+1次加减），速度快。

![图 6.3.4-3 不恢复余数法例题图1](/img/post_article/计算机组成原理/6.3.4-3.png)
![图 6.3.4-4 不恢复余数法例题图2](/img/post_article/计算机组成原理/6.3.4-4.png)

**3. 硬件配置**
*   寄存器A、X、Q、加法器均 𝑛 + 1 位
*   A：被除数的原码、余数。
*   X：除数的原码
*   Q（MQ）：商的原码
*   用 $Q_n$ 控制加减交替：
    *   $Q_n$ = 1：左移一位，做减法
    *   $Q_n$ = 0：左移一位，做加法
*   计数器C（计数器值 = 移位次数 = 数值部分位数 = 𝑛，每移位一次，计数器值减1）
*   S：商符（值 = 被除数和除数的符号位进行异或）
*   $G_D$：除法标志
*   V：溢出标志

![图 6.11 除法运算硬件配置](/img/post_article/计算机组成原理/6-11.png)

### 6.4 浮点四则运算

浮点数的一般表达式为：$N = S \times r^j$
*   **$S$ (Significand/Mantissa)**：尾数，用定点小数表示，决定了浮点数的**精度**。
*   **$j$ (Exponent)**：阶码，用定点整数表示，决定了浮点数的**表示范围**。
*   **$r$ (Base)**：基值，计算机中通常取 2、4、8 或 16。

#### 6.4.1 浮点加减运算

**1. 对阶 (Alignment)**
**目的**：使两个操作数的阶码相等，从而对齐小数点。
*   **计算阶差**：$\Delta j = j_x - j_y$。
*   **对阶原则**：**小阶向大阶看齐**。
    *   **原因**：尾数右移（阶码变大）只会丢失末位精度；若尾数左移（阶码变小）则可能丢失高位有效数值，导致严重错误。
*   **操作**：阶码小的数，尾数每右移一位，其阶码加 1，直到两数阶码相等。

**2. 尾数求和 (Addition/Subtraction of Mantissas)**
*   将对阶后的两个尾数按定点小数的加减法规则进行运算。
*   通常采用**补码**逻辑进行加减。

**3. 规格化 (Normalization)**
**目的**：使尾数尽可能占据有效位，以保证运算精度。规格化数的定义是 $1/r \le |S| < 1$。

*   **硬件判断标准 (补码)**：符号位与第一数值位不同。
    *   正数规格化形式：`00.1xx...x`
    *   负数规格化形式：`11.0xx...x`
*   **左规 (Left Shift Normalization)**：
    *   当运算结果尾数的高位出现连续相同的符号位（如 `00.0x` 或 `11.1x`）时，说明有效位太靠后。
    *   **操作**：尾数左移，阶码减 1，直到满足规格化条件。
*   **右规 (Right Shift Normalization)**：
    *   当尾数求和结果发生溢出（双符号位出现 `01` 或 `10`）时，说明绝对值 $> 1$。
    *   **操作**：尾数右移一位，阶码加 1。

**4. 舍入 (Rounding)**
在对阶或右规过程中，尾数末位可能丢失，需要进行舍入处理以提高精度：
*   **截断法**：直接舍去多余位，简单但误差较大。
*   **0舍1入法**：类似十进制四舍五入。被移去的最高数值位为 0 则直接舍去；为 1 则在末位加 1（可能导致再次溢出，需再做一次右规）。
*   **恒置“1”法**：无论丢弃什么，都将右移后的尾数末位置为 1。

**5. 溢出判断 (Overflow Judgment)**
浮点数的溢出不由尾数决定，而是由**阶码**决定：
*   **尾数溢出**：通过“右规”可以处理，不代表整个浮点数溢出。
*   **上溢 (Upper Overflow)**：规格化后，阶码超过了机器所能表示的最大正整数（如阶符为 `01`）。此时产生真溢出，需中断处理。
*   **下溢 (Lower Overflow)**：阶码小于机器能表示的最小负整数（如阶符为 `10`）。此时数值极小，计算机通常将其按“**机器零**”处理。

**6. 特例**

1.  **双符号位补码**：在运算过程中，阶码和尾数通常采用双符号位（如 `00` 表示正，`11` 表示负）来检测中间过程的溢出。
2.  **补码规格化特例**：
    *   $[ -1/2 ]_补 = 1.100...0$，符号位与第一位相同，在硬件判断中**不是**规格化的，需左规。
    *   $[ -1 ]_补 = 1.000...0$，符号位与第一位不同，被视为规格化的数。
3.  **算术移位规则**：
    *   正数补码：左右移均补 `0`。
    *   负数补码：左移补 `0`，右移补 `1`。

#### 6.4.2 浮点乘除法
*   **乘法**：阶码相加，尾数相乘。
*   **除法**：阶码相减，尾数相除。
*   运算后都需要规格化、舍入和溢出判断。

### 6.5 算术逻辑单元 (ALU)

#### 6.5.1 ALU电路 (Arithmetic Logic Unit)

**1. 基本概念**
*   **定义**：算术逻辑单元（ALU）是集成了算术运算和逻辑运算的运算电路。
*   **信号定义**：
    *   $A_i, B_i$：输入的两个操作数。
    *   $F_i$：运算结果。
    *   $K_i$：控制信号（操作码），其不同的取值决定 ALU 执行哪一种算术或逻辑运算。
*   **电路特性**：
    *   ALU 属于**组合逻辑电路**，没有记忆功能。输入信号消失，输出信号也会随之消失。
    *   为了保存结果并使运算稳定，ALU 的输入端和输出端通常都需要连接**寄存器**。

![图 6.3.5-1 ALU电路](/img/post_article/计算机组成原理/6.3.5-1.png)

**2. 四位 ALU 74181 外特性**
74181 是一款经典的 4 位 ALU 芯片，其主要引脚和功能如下：
*   **控制端**：
    *   $M = 0$：执行算术运算（有进位处理）。
    *   $M = 1$：执行逻辑运算（无进位处理）。
    *   $S_3 \sim S_0$：选择具体运算类型的控制位。
*   **输入/输出**：
    *   $A_3 A_2 A_1 A_0$ 与 $B_3 B_2 B_1 B_0$：两组 4 位输入操作数。
    *   $F_3 F_2 F_1 F_0$：4 位运算结果输出。
*   **进位与连接**：
    *   $C_{-1}$：最低位的外部进位输入。
    *   $C_{n+4}$：向高位的进位输出。
    *   $A=B$：判断相等信号（集电极开路输出）。
    *   $G, P$：用于**先行进位（Look-ahead Carry）**，分别为成组进位生成函数和成组进位传递函数。

![图 6.3.5-2 四位ALU 74181](/img/post_article/计算机组成原理/6.3.5-2.png)

#### 6.5.2 快速进位链

**1. 一位全加器 (Full Adder, FA)**

![图 6.3.5-3 一位全加器](/img/post_article/计算机组成原理/6.3.5-3.png)

*   **公式**：
    *   和数：$S_i = X_i \oplus Y_i \oplus C_i$
    *   进位：$C_{i+1} = X_i Y_i + (X_i \oplus Y_i) C_i$
*   **时间延迟假设**（单位 $T$）：
    *   与门/或门延迟 = $1T$
    *   异或门延迟 = $3T$
*   **单位延迟分析**：
    *   $S_i$ 的延迟为 $6T$（经过两次异或）。
    *   $C_{i+1}$ 的延迟为 $5T$（先经过一次异或 $3T$，再经过与门 $1T$ 和或门 $1T$）。

**2. n位串行进位加法器 (Ripple Carry Adder)**

![图 6.3.5-4 n位串行进位加法器](/img/post_article/计算机组成原理/6.3.5-4.png)

*   **原理**：高位全加器必须等待低位的进位信号 $C_i$ 产生后才能开始运算。
*   **延迟计算**：
    *   第 0 位进位 $C_1$：$5T$
    *   第 1 位进位 $C_2$：$7T$
    *   第 $n-1$ 位进位 $C_n$：$(2n+3)T$
    *   最后一位和数 $S_{n-1}$：$(2n+4)T$
    *   溢出信号 $Overflow$：$(2n+6)T$
*   **缺点**：运算速度受进位链长度限制，位宽 $n$ 越大，延迟越高。

**3. 并行进位加法器 (Carry Look-ahead Adder, CLA)**
为了提高速度，将进位公式改写：
*   $G_i = X_i Y_i$ （进位生成函数 Generate）
*   $P_i = X_i \oplus Y_i$ （进位传递函数 Propagate）
*   $C_{i+1} = G_i + P_i C_i$
*   **进位链展开**：
    *   $C_1 = G_0 + P_0 C_0$
    *   $C_2 = G_1 + P_1 G_0 + P_1 P_0 C_0$
    *   $C_3 = G_2 + P_2 G_1 + P_2 P_1 G_0 + P_2 P_1 P_0 C_0$
    *   $C_4 = G_3 + P_3 G_2 + P_3 P_2 G_1 + P_3 P_2 P_1 G_0 + P_3 P_2 P_1 P_0 C_0$
*   **特性**：进位输出 $C_n$ 仅与最低进位输入 $C_0$ 及操作数有关，各级进位可同时产生。通常每 4 位一组。

**4. 16位快速加法器与先行进位电路 (CLA 74182)**

![图 6.3.5-5 CLA 74182](/img/post_article/计算机组成原理/6.3.5-5.png)

通过成组进位实现更宽位数的加法：
*   **成组概念**：
    *   $G^*$ (成组进位生成函数)：$G^*_0 = G_3 + P_3 G_2 + P_3 P_2 G_1 + P_3 P_2 P_1 G_0$
    *   $P^*$ (成组进位传递函数)：$P^*_0 = P_3 P_2 P_1 P_0$
*   **CLA 74182 芯片逻辑**：
    *   $C_4 = G_0^* + P_0^* C_0$
    *   $C_8 = G_1^* + P_1^* C_4$
    *   $C_{12} = G_2^* + P_2^* C_8$
    *   $C_{16} = G_3^* + P_3^* C_{12}$

![图 6.3.5-6 16位快速加法器与先行进位电路](/img/post_article/计算机组成原理/6.3.5-6.png)

**5. 大体步骤**
1. $X_i, Y_i$ 产生 $G_i, P_i$
2. $G_i, P_i$ 产生 $G_i^*, P_i^*$
3. $G_i^*, P_i^*$ 产生 $C_4, C_8, C_{12}, C_{16}$
4. $C_4, C_8, C_{12}, C_{16}$ 产生 $C_{组内} C_{16}$
5. $C_{组内} C_{15}$ 产生 $S_0 \sim S_{15}$

**6. 时间延迟详细分析 (以 16 位加法器为例)**
*   **1T，** 产生组内 $G$：$G_0 \sim G_3, G_4 \sim G_7, G_8 \sim G_{11}, G_{12} \sim G_{15}$
*   **3T，** 产生组内 $P$：$P_0 \sim P_3, P_4 \sim P_7, P_8 \sim P_{11}, P_{12} \sim P_{15}$
*   **4T，** 产生各组 $P^*$：$P_3^*, P_2^*, P_1^*, P_0^*$
*   **5T，** 产生各组 $G^*$：$G_3^*, G_2^*, G_1^*, G_0^*$
*   **5T，** 产生第一个 4 位快速加法器的各进位 $C_4 \sim C_1$
*   **6T，** 产生 $S_0$，$S_0 = X_0 \oplus Y_0 \oplus C_0 = P_0 \oplus C_0$
*   **6T，** CLA 74182 产生 $C_4$
*   **7T，** CLA 74182 产生 $C_8, C_{12}, C_{16}$
*   **8T，** 产生 $S_1 \sim S_3$，产生第二个快速加法器各进位 $C_8 \sim C_5$
*   **9T：** 产生 $S_4$、$C_{16} \sim C_{13}$、$C_{12} \sim C_9$
*   **10T：** 产生 $S_8$、$S_{12}$
*   **11T：** 产生 $S_7 \sim S_5$
*   **12T：** 产生 $S_{15} \sim S_{13}$、$S_{11} \sim S_9$
*   **产生 $S_0 \sim S_{15}$ 总时间：12T**


**7. 32位快速加法器**
*   由两个16位快速加法器串联得到

![图 6.3.5-7 32位快速加法器](/img/post_article/计算机组成原理/6.3.5-7.png)

## 第7章 指令系统

### 7.1 机器指令

机器指令是计算机能够直接识别和执行的语句。所有机器指令的集合称为**指令系统**。指令系统决定了计算机的主要功能和硬件结构。

#### 7.1.1 指令的一般格式

指令由**操作码 (Opcode)** 和**地址码 (Address Code)** 两部分组成。

**1. 操作码**
*   **作用**：指明指令要完成的操作（如ADD, MOV, JMP）。
*   **位数**：操作码的位数反映了机器允许的指令条数。例如，操作码占7位，则最多有 $2^7=128$ 条指令。
*   **长度分类**：
    *   **固定长度**：操作码集中在指令字的一个固定字段。便于硬件设计，译码快，适用于字长较长的机器（如IBM 370）。
    *   **可变长度**：操作码分散在指令字的不同字段。
        *   **扩展操作码技术**：在指令字长固定的前提下，利用地址码字段位数的减少来增加操作码的位数。
        *   **原则**：使用频度高的指令占用短的操作码，使用频度低的指令占用长的操作码。

![图 7.2 一种扩展操作码的安排示意图](/img/post_article/计算机组成原理/7-2.png)

> *   **详细解读**：假设指令字长16位。
>     *   **三地址指令**：操作码4位（0000~1110），留出1111作为扩展标志。
>     *   **二地址指令**：操作码扩展到8位（1111 0000 ~ 1111 1110），留出1111 1111作为扩展。
>     *   **一地址指令**：操作码扩展到12位。
>     *   **零地址指令**：操作码扩展到16位。
> *   **结论**：操作码位数随地址数的减少而增加。

**2. 地址码**
地址码用来指出操作数地址、结果地址和下一条指令地址。假设指令字长32位，操作码8位，剩余24位用于地址。

*   **四地址指令**：`OP A1 A2 A3 A4`
    *   含义：$(A_1) OP (A_2) \rightarrow A_3$，下条指令地址为 $A_4$。
    *   **缺点**：指令太长，或者地址寻址范围太小。若4个地址均分24位，每个地址仅6位，只能寻址64个单元，太小。
    *   **改进**：程序计数器（PC）可以自动形成下条指令地址，省去 $A_4$。
*   **三地址指令**：`OP A1 A2 A3`
    *   含义：$(A_1) OP (A_2) \rightarrow A_3$。
    *   若地址字段各占8位，寻址范围 $2^8=256$。需访存4次（取指令1次+取A1+取A2+存A3）。
*   **二地址指令**：`OP A1 A2`
    *   含义：$(A_1) OP (A_2) \rightarrow A_1$ （结果存回A1，破坏了A1原有内容）。
    *   若地址字段各占12位，寻址范围 $2^{12}=4K$。需访存4次（若结果暂存在ACC，则只需3次）。
*   **一地址指令**：`OP A1`
    *   含义：$(ACC) OP (A_1) \rightarrow ACC$。
    *   隐含了一个操作数在累加器ACC中。地址范围可达 $2^{24}=16M$。需访存2次。
*   **零地址指令**：`OP`
    *   无地址码。
    *   应用：
        1.  不需要操作数的指令（如空操作NOP、停机HLT）。
        2.  **堆栈计算机**：操作数隐含在栈顶和次栈顶，运算结果压回栈顶。

#### 7.1.2 指令字长

*   **定义**：一条指令中所包含的二进制代码的位数。
*   **关系**：指令字长 = 操作码长度 + 操作数地址长度 × 操作数地址个数。
*   **分类**：
    *   **单字长指令**：指令长度 = 机器字长。
    *   **半字长/双字长指令**：指令长度是机器字长的0.5倍或2倍。
*   **发展趋势**：从固定字长（早期）发展到**变长指令**（如x86），以节省存储空间。为了提高速度，现代RISC机器又回归到**固定字长**。
*   **注意**：指令字长通常取字节的整数倍。

### 7.2 操作数类型和操作类型

#### 7.2.1 操作数类型

1.  **地址**：无符号整数，用来计算有效地址。
2.  **数字**：
    *   定点数、浮点数（参见第6章）。
    *   十进制数（BCD码）：用4位二进制表示1位十进制。
3.  **字符**：普遍采用ASCII码。
4.  **逻辑数据**：用于逻辑运算（与、或、非等），每一位独立表示真/假，没有进位关系。

#### 7.2.2 数据在存储器中的存放方式

由于机器字长和数据字长可能不同（例如机器字长32位，但要存16位数据或8位字符），存在存储对齐问题。

![图 7.3 存储器中数据的存放](/img/post_article/计算机组成原理/7-3.png)

> *   **图(a) 对准边界**：数据起始地址必须是其长度的整数倍（如32位数据地址必须是4的倍数）。
>     *   **优点**：一次访存即可取出完整数据，速度快。
>     *   **缺点**：会产生内部碎片，浪费存储空间。
> *   **图(b) 不对准边界**：数据可以紧凑存放。
>     *   **优点**：节省空间。
>     *   **缺点**：一个数据可能跨越两个存储字，需要两次访存才能取出，速度慢，控制复杂。

**字节次序（Byte Ordering）**：
*   **大端 (Big-Endian)**：高位字节存放在低地址（符合人类阅读习惯，如IBM 370）。
*   **小端 (Little-Endian)**：低位字节存放在低地址（Intel常用）。

![图 7.4 两种字节次序](/img/post_article/计算机组成原理/7-4.png)

> *   **理解**：假设数据是 Hex `1234`。小端模式下，低地址存 `34`，高地址存 `12`。大端反之。

#### 7.2.3 操作类型

1.  **数据传送**：
    *   源与目的之间的拷贝。包括寄存器与寄存器、寄存器与存储器（LOAD/STORE）、堆栈操作（PUSH/POP）。
2.  **算术逻辑操作**：
    *   加减乘除、与或非异或。
3.  **移位**：
    *   算术移位、逻辑移位、循环移位。
4.  **转移**（改变程序执行顺序）：
    *   **无条件转移**：`JMP X`。
    *   **条件转移**：根据状态标志（如零标志Z、溢出标志V）决定是否转移。如 `JZ` (结果为0则转)。
    *   **调用与返回**：`CALL` 和 `RETURN`。用于子程序，必须保存返回地址（通常压栈）。

![图 7.5 调用和返回指令示意图](/img/post_article/计算机组成原理/7-5.png)

> *   **理解**：执行CALL时，把下一条指令的地址（断点）压入堆栈，然后跳到子程序。执行RETURN时，从堆栈弹出断点赋给PC。
> *   **陷阱 (Trap)**：意外事故或中断（软中断），启动系统内部的处理程序。

5.  **输入输出**：
    *   `IN` / `OUT` 指令，用于独立编址的I/O系统，完成CPU与I/O端口间的数据传输。
6.  **其他**：
    *   实现其他控制功能的指令，如停机、等待指令。

### 7.3 寻址方式

寻址方式是指确定**本条指令的数据地址**以及**下一条将要执行的指令地址**的方法。

#### 7.3.1 指令寻址

1.  **顺序寻址**：通过程序计数器（PC）加Δ（这里的Δ指指令长度），自动指向下一条指令。`PC + Δ -> PC`。
2.  **跳跃寻址**：由转移指令指出下条指令地址，直接修改PC的内容。

![图 7.6 指令的寻址方式示意图](/img/post_article/计算机组成原理/7-6.png)

> *   **理解**：大部分时间PC自动+1往下走，遇到JMP指令时，PC被强行改成跳转目标的地址。

#### 7.3.2 数据寻址

指令格式通常为：`操作码 | 寻址特征 | 形式地址A`。
*   **形式地址 A**：指令字中给出的地址。
*   **有效地址 EA (Effective Address)**：操作数在存储器中的真实地址。

以下是常见的寻址方式：

**1. 立即寻址**
*   **定义**：形式地址A就是**操作数本身**（立即数）。通常用 `#` 号表示。
*   **特点**：不需要访问存储器取数据，速度快。但数值范围受A的位数限制。

![图 7.8 立即寻址示意图](/img/post_article/计算机组成原理/7-8.png)

**2. 直接寻址**
*   **定义**：$EA = A$。形式地址就是真实地址。
*   **特点**：简单，访存1次。但A的位数限制了寻址范围。

![图 7.9 直接寻址示意图](/img/post_article/计算机组成原理/7-9.png)

**3. 隐含寻址**
*   **定义**：操作数地址不显式给出，而是隐含在操作码或寄存器中。例如 `ADD A`，另一个操作数隐含在 ACC 中。
*   **特点**：缩短指令字长。

![图 7.10 隐含寻址示意图](/img/post_article/计算机组成原理/7-10.png)

**4. 间接寻址**
*   **定义**：$EA = (A)$。A指向的存储单元中的内容才是有效地址。
    *   **一次间接**：A -> EA -> 操作数。
    *   **多次间接**：A -> 地址 -> ... -> EA -> 操作数（通常用存储字首位标志是否结束）。
*   **特点**：扩大寻址范围（用短地址寻址长空间），便于编制程序（如子程序返回）。但需多次访存，速度慢。

![图 7.11 间接寻址示意图](/img/post_article/计算机组成原理/7-11.png)

**5. 寄存器寻址**
*   **定义**：$EA = R_i$。地址码给出的是寄存器编号，操作数在寄存器中。
*   **特点**：不访问主存，速度极快，指令字短（寄存器编号短）。广泛使用。

![图 7.13 寄存器寻址示意图](/img/post_article/计算机组成原理/7-13.png)

**6. 寄存器间接寻址**
*   **定义**：$EA = (R_i)$。寄存器 $R_i$ 中的内容是有效地址，操作数在主存中。
*   **特点**：比间接寻址少访问一次主存，便于循环程序设计。

![图 7.14 寄存器间接寻址示意图](/img/post_article/计算机组成原理/7-14.png)

**7. 基址寻址 (Base Addressing)**
*   **定义**：$EA = (BR) + A$。有效地址 = **基址寄存器**（**BR**）的内容 + 形式地址A（位移量）。
    *   **隐式**：计算机专门设有一个BR。
    *   **显式**：通用寄存器组中指定一个作为BR。
*   **特点**：
    *   **面向系统**：BR的内容由操作系统管理，**用户不可修改**，用户只能修改A。
    *   用于**多道程序设计**，解决程序在主存中的动态定位问题（逻辑地址变物理地址）。
    *   扩大寻址范围。

![图 7.15 基址寻址示意图](/img/post_article/计算机组成原理/7-15.png)

**8. 变址寻址 (Indexed Addressing)**
*   **定义**：$EA = (IX) + A$。有效地址 = **变址寄存器**（**IX**）的内容 + 形式地址A。
*   **特点**：
    *   **面向用户**：用户可以修改IX的内容，**指令中的A不可变**（作为基准地址）。
    *   特别适合处理**数组**问题（IX作为下标，A为数组首地址）。

![图 7.16 变址寻址示意图](/img/post_article/计算机组成原理/7-16.png)

*   **基址寻址与变址寻址复合使用**：

![图 7.16.2 基址寻址与变址寻址复合示意图](/img/post_article/计算机组成原理/7-16.2.png)

**9. 相对寻址 (Relative Addressing)**
*   **定义**：$EA = (PC) + A$。有效地址 = **程序计数器PC**的内容 + 形式地址A（位移量）。
*   **特点**：
    *   A通常是补码，可正可负。
    *   便于程序**浮动**（代码在内存中移动位置后，相对跳转关系不变）。
    *   广泛用于**转移指令**。

![图 7.17 相对寻址示意图](/img/post_article/计算机组成原理/7-17.png)

**10. 堆栈寻址**
*   **定义**：操作数在堆栈栈顶。堆栈指针 (SP) 隐含指出栈顶地址。
*   **硬堆栈**：寄存器组实现。
*   **软堆栈**：主存区域实现。SP 的修改与主存编址方法有关
    *   软堆栈进栈：将指定数据传送到堆栈中
        *   （SP）– 1 → SP
    *   软堆栈出栈 ：将栈顶数据传送给指定的寄存器
        *   （SP）+ 1 → SP
*   **操作**：PUSH（进栈）和 POP（出栈）。SP会自动加减。

![图 7.18 堆栈寻址示意图](/img/post_article/计算机组成原理/7-18.png)

### 7.4 指令格式举例

#### 7.4.1 设计指令格式应考虑的各种因素
1.  **操作类型**：指令数及复杂度。
2.  **数据类型**：确定哪些数据类型可参与操作。
3.  **指令格式**：字长、操作码位数、地址码位数等。
4.  **寻址方式**：提供哪些寻址方式。
5.  **寄存器个数**：直接影响指令执行速度。

#### 7.4.2 指令格式举例
*   **PDP-8**：固定字长12位。
*   **PDP-11**：变长指令，扩展操作码。
*   **IBM 360**：固定字长32位，RR（寄存器-寄存器）、RX（寄存器-存储器）等格式。
*   **Intel x86**：变长指令（1~15字节），极其复杂。

#### 7.4.3 指令格式设计举例

**例题逻辑**：
假设指令字长16位，地址码6位。
*   如果全是二地址指令：`OP(4位) + A1(6位) + A2(6位)`。最多 $2^4=16$ 条。
*   如果想保留一些作为一地址指令，可以拿出二地址指令中的一种操作码（比如 `1111`）作为扩展标志。
    *   当高4位不是 `1111` 时，是二地址指令（共15条）。
    *   当高4位是 `1111` 时，剩下的 `A1(6位)` 变成了操作码的一部分。此时操作码变为 $4+6=10$ 位，后跟 `A2(6位)`。
    *   这样可以扩展出一地址指令 $2^6 = 64$ 条（或者留一部分给零地址指令）。

![图 7.22 例7.4五种指令格式](/img/post_article/计算机组成原理/7-22.png)

> *   **说明**：展示了如何在一个固定字长内，通过扩展操作码，容纳二地址、一地址、零地址等多种格式。

### 7.5 RISC 技术

**CISC (Complex Instruction Set Computer)**：复杂指令系统计算机。
*   **背景**：为了缩短机器指令与高级语言的差距，指令越来越复杂，字长不固定。
*   **问题**：**80-20规律** —— 典型程序中80%的语句只使用了20%的简单指令，而复杂的指令很少用到，却极大地增加了硬件设计的负担。

**RISC (Reduced Instruction Set Computer)**：精简指令系统计算机。

#### 7.5.1 RISC 的产生和发展
基于对CISC缺点的反思，IBM 801、Berkeley RISC、MIPS等项目推动了RISC的发展。

#### 7.5.2 RISC 的主要特征 (核心考点)
1.  **指令少**：只选用使用频度高的一些简单指令。
2.  **寻址方式少**：简化译码复杂度。
3.  **格式规整**：**指令长度固定**，指令格式少。
4.  **Load/Store结构**：只有取数/存数指令访问存储器，其余运算都在**寄存器**之间进行。
5.  **寄存器多**：CPU内部有大量通用寄存器，减少访存。
6.  **流水线技术**：大部分指令在一个时钟周期内完成。
7.  **硬布线控制**：控制器采用组合逻辑电路（硬布线），不用微程序，速度快。

#### 7.5.3 RISC 和 CISC 的比较
*   **CISC**：
    *   指令丰富，功能强，但硬件复杂。
    *   指令长度不固定。
    *   微程序控制为主。
    *   适合兼容旧软件。
*   **RISC**：
    *   指令精简，硬件简单，芯片面积利用率高。
    *   指令长度固定，译码快。
    *   硬布线控制为主。
    *   **速度快**（流水线效率高）。
    *   依赖**优化编译器**来生成高效代码。

![表 7.3 IBM 370机指令的使用频率（%）](/img/post_article/计算机组成原理/Table7-3.png)
> *   **说明**：数据证明了简单指令（如赋值、加法）占据了绝大多数执行时间，佐证了RISC的设计理念。

## 第8章 CPU的结构和功能

### 8.1 CPU的结构

#### 8.1.1 CPU的功能

CPU（中央处理器）由运算器和控制器组成。控制器的主要功能是负责协调并控制计算机各部件执行程序的指令序列。

**1. 控制器的基本功能**
*   **取指令**：自动从存储器中取出指令。控制器必须能自动形成指令地址，并发命令取指令。
*   **分析指令**：
    1.  分析指令要完成什么操作（译码）。
    2.  分析操作数的有效地址。
*   **执行指令**：根据分析结果，形成操作控制信号序列，指挥各部件（运算器、存储器、I/O）完成操作。
*   **其他功能**：
    *   控制程序输入和结果输出。
    *   总线管理。
    *   **处理中断**：处理异常情况（如掉电）和特殊请求（如打印机请求）。

**2. CPU的总体功能总结**
*   **指令控制**：控制指令的顺序执行（控制取指令）。
*   **操作控制**：产生完成每条指令所需的控制命令。
*   **时间控制**：对各种操作加以时间上的控制。
*   **数据加工**：对数据进行算术运算和逻辑运算。
*   **处理中断**：处理异常情况和特殊请求。

#### 8.1.2 CPU结构框图

![图 8.2 CPU的内部结构](/img/post_article/计算机组成原理/8-2.png)

> *   **描述**：CPU内部通过**片内总线**连接各部件。
>     *   **ALU**：算术逻辑单元，负责运算。
>     *   **寄存器**：存放数据和地址。
>     *   **中断系统**：处理中断。
>     *   **CU (Control Unit)**：控制单元，发出控制信号。

#### 8.1.3 CPU的寄存器

寄存器用于暂存指令、数据和地址，速度极快。分为两类：

**1. 用户可见寄存器**（程序员可编程使用）
*   **通用寄存器**：功能多样，可存放操作数、基址、变址、栈指针等。
    *   *例子*：R0~R3, AX, BX等。
*   **数据寄存器**：存放操作数。
*   **地址寄存器**：存放地址（如段指针、变址寄存器）。
*   **条件码寄存器**：存放状态标志（如零标志Z、溢出标志V、进位标志C等），用于分支判断。

**2. 控制和状态寄存器**（用户不可见，由CU使用）
*   **MAR (Memory Address Register)**：存储器地址寄存器。存放欲访问的存储单元地址。
*   **MDR (Memory Data Register)**：存储器数据寄存器。存放读/写的数据。
*   **PC (Program Counter)**：程序计数器。存放**现行指令**的地址，并能自动加1形成下条指令地址。
*   **IR (Instruction Register)**：指令寄存器。存放**当前欲执行**的指令。
*   **PSW (Program Status Word)**：程序状态字寄存器。存放状态标志和控制信息。

#### 8.1.4 控制单元和中断系统
*   **CU**：产生微操作命令序列。实现方法有**硬连线**（组合逻辑）和**微程序**设计。
*   **中断系统**：处理各种中断请求。

### 8.2 指令周期

#### 8.2.1 指令周期的基本概念

*   **指令周期**：CPU取出并执行一条指令所需的全部时间。
*   **基本组成**：**取指周期** + **执行周期**。
    *   *注*：不同指令的周期长度不同（如NOP指令很短，乘法指令很长）。
*   **取指周期**：完成取指令和分析指令的操作。
*   **执行周期**：完成执行指令的操作。

![图 8.5 指令周期定义示意图](/img/post_article/计算机组成原理/8-5.png)

*   **间址周期**：当遇到间接寻址的指令时，由于指令字中只给出操作数有效地址的地址，因此，为了取出操作数，需先访问一次存储器，取出有效地址，然后再访问存储器，取出操作数。

![图 8.7 具有间址周期的指令周期](/img/post_article/计算机组成原理/8-7.png)

*   **中断周期**：响应中断请求，保护程序断点、寻找中断服务程序的入口地址、关中断。

![图 8.8 指令周期流程](/img/post_article/计算机组成原理/8-8.png)

> *   **完整流程**：
>     1.  **取指周期**：取指令。
>     2.  **间址周期**（可选）：如果是间接寻址，需访存取有效地址。
>     3.  **执行周期**：执行操作。
>     4.  **中断周期**（可选）：若有中断请求，且允许中断，则进入中断处理。

*   **标志触发器**：为了区别当前处于哪个周期，CPU内部通常设有标志触发器：
    *   **FE**：取指周期。
    *   **IND**：间址周期。
    *   **EX**：执行周期。
    *   **INT**：中断周期。

#### 8.2.2 指令周期的数据流

**1. 取指周期数据流**
为了便于分析指令周期中的数据流，假设 CPU 中有存储器地址寄存器 MAR 、存储器数据寄存器 MDR 、程序计数器 PC 和指令寄存器 IR。
1.  **PC $\to$ MAR $\to$ 地址总线 $\to$ 存储器**。
2.  **CU 发读命令**。
3.  **存储器 $\to$ 数据总线 $\to$ MDR $\to$ IR**。
4.  **CU 控制 PC + 1**。

![图 8.10 取指周期数据流](/img/post_article/计算机组成原理/8-10.png)

**2. 间址周期数据流**
1.  **MDR (形式地址) $\to$ MAR $\to$ 地址总线 $\to$ 存储器**。
2.  **CU 发读命令**。
3.  **存储器 $\to$ 数据总线 $\to$ MDR (有效地址)**。

![图 8.11 间址周期数据流](/img/post_article/计算机组成原理/8-11.png)

**3. 执行周期数据流**
视具体指令而定。

**4. 中断周期数据流**（保存断点，转中断服务程序）
1.  **CU (堆栈指针/特定地址) $\to$ MAR $\to$ 地址总线 $\to$ 存储器**。
2.  **CU 发写命令**。
3.  **PC (断点) $\to$ MDR $\to$ 数据总线 $\to$ 存储器**。
4.  **CU (入口地址) $\to$ PC**。

![图 8.12 中断周期数据流](/img/post_article/计算机组成原理/8-12.png)

### 8.3 指令流水

#### 8.3.1 指令流水原理

*   **串行执行**：取指1 $\to$ 执行1 $\to$ 取指2 $\to$ 执行2...（设备利用率低）。
*   **二级流水**：取指1和执行1同时进行（假设取指和执行部件独立）。
    *   *理想情况*：速度加倍。
    *   *制约因素*：
        1.  执行时间 > 取指时间（需设缓冲等待）。
        2.  **条件转移指令**：不知道下条指令地址，造成断流。

**六级流水线示例**：
将指令处理分解为6个阶段：
1.  **FI**：取指。
2.  **DI**：译码。
3.  **CO**：计算操作数地址。
4.  **FO**：取操作数。
5.  **EI**：执行。
6.  **WO**：写回结果。

![图 8.15 指令六级流水时序](/img/post_article/计算机组成原理/8-15.png)

> *   **描述**：各条指令像工厂流水线一样重叠进行。理想情况下，每隔一个时钟周期就有一条指令完成。

#### 8.3.2 影响流水线性能的因素

**1. 结构相关 (资源冲突)**
*   **原因**：多条指令争用同一硬件资源（如访存冲突）。
    *   例如：某条指令处于MEM段（访存取数），另一条处于IF段（取指），若指令和数据在同一存储器，则发生冲突。
*   **解决**：
    *   暂停流水线（插入气泡）。
    *   **哈佛结构**：指令存储器和数据存储器分开。
    *   指令预取队列。

**2. 数据相关 (数据冲突)**
*   **原因**：后继指令需要用到前面指令的执行结果，但前面指令还没写回。
    *   **RAW (写后读)**：最常见。
    *   **WAR (读后写)**。
    *   **WAW (写后写)**。
*   **解决**：
    *   **后推法**：暂停流水线，直到结果生成。
    *   **定向技术 (旁路技术)**：将ALU的输出直接作为下一条指令的输入，而不必等待写回寄存器。

**3. 控制相关 (控制冲突)**
*   **原因**：**转移指令**改变了PC值，导致预取的后续指令无效。
*   **解决**：
    *   **分支预测**：猜测分支走向（如猜测不转移）。
    *   **预取两个方向**。
    *   **延迟槽**。

#### 8.3.3 流水线性能

1.  **吞吐率 (TP)**：单位时间内流水线完成指令的数量。
    *   最大吞吐率 $TP_{max} = 1 / \Delta t$ （$\Delta t$为时钟周期）。
    *   实际吞吐率小于最大值（有建立时间）。
2.  **加速比 (S)**：不使用流水线时间 / 使用流水线时间。
    *   $S = \frac{nm\Delta t}{m\Delta t + (n-1)\Delta t} \approx m$ （n为指令数，m为级数）。
    *   理想加速比等于流水线级数 $m$。
3.  **效率 (E)**：流水线各段的利用率。
    *   即时空图中，任务占用的面积 / 总面积。

#### 8.3.4 流水线中的多发技术

为了在一个时钟周期内发射多条指令：

1.  **超标量技术 (Superscalar)**
    *   **特点**：配置**多个功能部件**，每个周期并发多条独立指令。
    *   **要求**：硬件资源丰富，编译优化（指令调度）。
2.  **超流水线技术 (Superpipeline)**
    *   **特点**：将流水线分得**更细**，时钟频率更高。在一个原时钟周期内分段发出多条指令。
3.  **超长指令字技术 (VLIW)**
    *   **特点**：由**编译器**挖掘并行性，将多条能并行的指令组合成一条超长指令。

#### 8.3.5 流水线结构

流水线技术不仅可以用于整个指令的执行过程（宏观），也可以用于运算器内部的具体运算操作（微观）。

**1. 指令流水线结构**

**核心思想**：
将一条指令的执行过程像切香肠一样，切成若干个**独立的阶段**，每个阶段由**专门的硬件电路**来完成。

书中列举了一个典型的7段流水线（实际机器可能不同，但原理一致）：
1.  **取指令部件**：负责从内存拿指令。
2.  **指令译码部件**：翻译指令是干嘛的。
3.  **地址形成部件**：计算操作数在哪里。
4.  **取操作数部件**：把数据拿出来。
5.  **操作执行部件**：ALU干活（加减乘除）。
6.  **回写结果部件**：把算好的数写回去。
7.  **修改指令指针部件**：决定下一条指令在哪（PC+1或跳转）。

![图 8.21 指令流水线结构框图](/img/post_article/计算机组成原理/8-21.png)

> *   **描述**：图画得像一条生产线，上述7个部件依次排开，箭头单向流动。
> *   **理解**：这就好比工厂里装配汽车，有人专门装轮子，有人专门装发动机。指令就是汽车，流过这7个工位，最后成品出厂。

**性能提升**
*   如果把处理过程分解成 $k$ 个**时间相等**的阶段。
*   理想情况下（不断流），速度可以提高到原来的 **$k$ 倍**。

**2. 运算流水线**

流水线技术不仅用于指令整体，还可以深入到**部件内部**。比如做一个复杂的浮点加法运算，也可以用流水线。

为了让这三个阶段能流水作业，必须在**相邻两段之间设置锁存器（寄存器）**。

![图 8.22 浮点加运算操作流水线](/img/post_article/计算机组成原理/8-22.png)

> *   **描述**：图中展示了三级流水：
>     *   第一级：对阶功能部件 $\rightarrow$ 锁存器
>     *   第二级：尾数加部件 $\rightarrow$ 锁存器
>     *   第三级：规格化部件 $\rightarrow$ 锁存器
> *   **理解**：
>     *   **锁存器的作用**：就像接力赛跑时的接力棒交接区，或者是生产线上的暂存盘。
>     *   **为什么要它？** 保证第1阶段做完的结果先存起来，传给第2阶段；同时第1阶段可以立刻去处理下一个数据的对阶，互不干扰。

### 8.4 中断系统

中断系统用于处理随机事件。

#### 8.4.1 概述

**1. 中断因素**
*   **人为设置**：如转管指令（软中断）。
*   **程序性事故**：溢出、除数为0、非法指令。
*   **硬件故障**：掉电、校验错、通风不良、磁盘损坏
*   **I/O设备**：I/O完成请求。
*   **外部事件**：键盘中断等。

**2. 中断系统须解决的问题**
*   各中断源如何向 CPU 提出中断请求。
*   当多个中断源同时提出中断请求时，中断系统如何确定优先响应哪个中断源的请求。
*   CPU 在什么条件、什么时候、以什么方式来响应中断。
*   CPU 响应中断后如何保护现场。
*   CPU 响应中断后，如何停止原程序的执行而转入中断服务程序的入口地址。
*   中断处理结束后， CPU 如何恢复现场，如何返回到原程序的间断处。
*   在中断处理过程中又出现了新的中断请求， CPU 该如何处理。

**3. 中断源分类**
*   **不可屏蔽中断**：CPU必须响应（如掉电）。
*   **可屏蔽中断**：CPU可根据屏蔽位决定是否响应（如I/O请求）。

#### 8.4.2 中断请求标记和中断判优逻辑

**1. 中断请求标记**
*   **INTR**：中断请求触发器。每个中断源有一个，置“1”表示有请求。
*   组成中断请求寄存器。

![图 8.24 中断请求标记寄存器](/img/post_article/计算机组成原理/8-24.png)

**2. 中断判优**
当多个中断源同时请求时，需决定响应哪个。优先响应对计算机工作影响最大、最重要的中断请求.
*   **中断判优**：按中断请求的优先顺序响应中断请求。
*   **硬件排队**：
    *   **链式排队器**：优先级由物理连接位置决定（越靠近CPU越高）。
    *   **集中式排队器**（在CPU内）。

![图 8.25 集中在 CPU 内的排队器](/img/post_article/计算机组成原理/8-25.png)

*   **软件排队**：通过查询程序顺序决定。

![图 8.26 按A>B>C.., 优先级别的软件排队](/img/post_article/计算机组成原理/8-26.png)

#### 8.4.3 中断服务程序入口地址的寻找

**1. 硬件向量法**（现代常用）
*   由**硬件**产生**向量地址**。
*   向量地址指向存储单元，该单元存放跳转指令或服务程序入口地址。
*   **优点**：速度快。

![图 8.27 集中在 CPU 内的向量地址形成部件，中断向量地址表](/img/post_article/计算机组成原理/8-27.png)

**2. 软件查询法**
*   通过程序查询判断是谁请求，再跳转。

#### 8.4.4 中断响应

**1. 响应条件**
*   有中断请求。
*   CPU允许中断（**EINT = 1**，开中断）。
*   **一条指令执行完毕**（对于I/O中断）。

**2. 响应时间**
*   一般在指令执行周期结束后。
*   在指令执行周期结束时，CPU发出中断查询信号，查询是否有中断请求。有，进入中断周期；无，进入下一条指令的取指周期。

**3. 中断隐指令**
CPU响应中断后，自动执行一系列操作（不是程序员写的指令，是硬件做的），称为**中断隐指令**：
1.  **保护程序断点**：将PC内容压栈或存入特定地址。
2.  **寻找入口地址**：获取向量地址，送入PC。
3.  **关中断**：置 EINT = 0，防止从单重中断被再次打断。

#### 8.4.5 保护现场和恢复现场

*   **保护现场**：
    1.  **断点**：由中断隐指令完成。
    2.  **寄存器内容**：由中断服务程序（PUSH指令）完成。
*   **恢复现场**：服务程序结束前，恢复寄存器（POP），最后执行中断返回指令（恢复PC，并开中断）。

#### 8.4.6 中断屏蔽技术

**1. 多重中断（中断嵌套）**
*   **定义**：在执行中断服务程序时，响应级别更高的中断请求。
*   **条件**：
    1.  提前设置“开中断”指令。
    2.  优先级高的能打断低的。

**2. 屏蔽技术**
*   **屏蔽触发器 (MASK)**：MASK=1 表示屏蔽该中断。
*   **屏蔽字**：
    *   每个中断源有一个屏蔽字。
    *   通过设置屏蔽字，可以动态改变**处理优先级**（响应优先级通常固定，处理优先级可变）。
    *   *原则*：屏蔽自己和比自己级别低的中断。

![图 8.36 采用屏蔽技术的中断服务程序](/img/post_article/计算机组成原理/8-36.png)

> *   **流程**：
>     1.  保护现场。
>     2.  **置屏蔽字**（屏蔽当前及低级中断）。
>     3.  **开中断**（允许高级中断打断）。
>     4.  **中断服务**（核心处理）。
>     5.  **关中断**。
>     6.  **恢复屏蔽字**。
>     7.  恢复现场。
>     8.  **开中断**。
>     9.  中断返回。

*   **总结**：中断系统软硬件配合：
    *   **中断请求、判优、响应（隐指令）** $\to$ **硬件**。
    *   **保护现场、服务、恢复现场** $\to$ **软件**（服务程序）。
    *   **优先级控制** $\to$ **软硬结合**（硬件排队+软件屏蔽字）。